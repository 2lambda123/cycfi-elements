/*=================================================================================================   Copyright (c) 2016 Joel de Guzman   Licensed under a Creative Commons Attribution-ShareAlike 4.0 International.   http://creativecommons.org/licenses/by-sa/4.0/=================================================================================================*/#include <photon/widget/analog.hpp>#include <photon/support/context.hpp>#include <photon/view.hpp>namespace photon{   analog::analog(widget_ptr indicator_, widget_ptr body_, double init_value)    : _indicator(indicator_)    , _body(body_)    , _value(init_value)   {}   analog::~analog()   {}   void analog::draw(context const& ctx)   {      if (intersects(ctx.bounds, ctx.view.dirty()))      {         {            context sctx { ctx, _body.get(), ctx.bounds };            prepare_body(sctx);            _body->draw(sctx);         }         {            context sctx { ctx, _indicator.get(), ctx.bounds };            prepare_indicator(sctx);            _indicator->draw(sctx);         }      }   }   void analog::begin_tracking(context const& ctx, point start)   {      track(ctx, start);   }   void analog::keep_tracking(context const& ctx, info& track_info)   {      if (track_info.current != track_info.previous)         track(ctx, track_info.current);   }   void analog::end_tracking(context const& ctx, point stop)   {      track(ctx, stop);   }   void analog::track(context const& ctx, point p)   {      double new_value = value(ctx, p);      if (_value != new_value)      {         _value = new_value;         ctx.view.refresh(ctx.bounds);      }   }   void analog::prepare_indicator(context& ctx)   {}   void analog::prepare_body(context& ctx)   {}}