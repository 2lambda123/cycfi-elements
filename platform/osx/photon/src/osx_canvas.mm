/*=================================================================================================   Copyright (c) 2016 Joel de Guzman   Licensed under a Creative Commons Attribution-ShareAlike 4.0 International.   http://creativecommons.org/licenses/by-sa/4.0/=================================================================================================*/#include <photon/support/canvas.hpp>#include <Quartz/Quartz.h>struct canvas_impl;namespace photon{   void canvas::begin_path()   {      CGContextBeginPath(CGContextRef(_impl));   }   void canvas::close_path()   {      CGContextClosePath(CGContextRef(_impl));   }   void canvas::fill()   {      CGContextFillPath(CGContextRef(_impl));   }   void canvas::stroke()   {      CGContextStrokePath(CGContextRef(_impl));   }   void canvas::move_to(point p)   {      CGContextMoveToPoint(CGContextRef(_impl), p.x, p.y);   }   void canvas::line_to(point p)   {      CGContextAddLineToPoint(CGContextRef(_impl), p.x, p.y);   }   void canvas::arc_to(point p1, point p2, float radius)   {      CGContextAddArcToPoint(         CGContextRef(_impl),         p1.x, p1.y, p2.x, p2.y, radius      );   }   void canvas::arc(      point p, float radius,      float start_angle, float end_angle,      bool ccw   )   {      CGContextAddArc(         CGContextRef(_impl),         p.x, p.y, radius, start_angle, end_angle, !ccw      );   }   void canvas::fill_color(color c)   {      CGContextSetRGBFillColor(CGContextRef(_impl), c.red, c.green, c.blue, c.alpha);   }   void canvas::stroke_color(color c)   {      CGContextSetRGBStrokeColor(CGContextRef(_impl), c.red, c.green, c.blue, c.alpha);   }   void canvas::line_width(float w)   {      CGContextSetLineWidth(CGContextRef(_impl), w);   }   void canvas::fill_rect(rect r)   {      CGContextFillRect(CGContextRef(_impl), CGRectMake(r.left, r.top, r.width(), r.height()));   }   namespace   {      void rounded_rect(canvas& c, rect bounds, float radius)      {         auto x = bounds.left;         auto y = bounds.top;         auto r = bounds.right;         auto b = bounds.bottom;         c.begin_path();         c.move_to(point{ x, y + radius });         c.line_to(point{ x, b - radius });         c.arc_to(point{ x, b }, point{ x + radius, b }, radius);         c.line_to(point{ r - radius, b });         c.arc_to(point{ r, b }, point{ r, b - radius }, radius);         c.line_to(point{ r, y + radius });         c.arc_to(point{ r, y }, point{ r - radius, y }, radius);         c.line_to(point{ x + radius, y });         c.arc_to(point{ x, y }, point{ x, y + radius }, radius);      }   }   void canvas::fill_round_rect(rect r, float radius)   {      rounded_rect(*this, r, radius);      fill();   }   void canvas::stroke_rect(rect r)   {      CGContextStrokeRect(CGContextRef(_impl), CGRectMake(r.left, r.top, r.width(), r.height()));   }   void canvas::stroke_round_rect(rect r, float radius)   {      rounded_rect(*this, r, radius);      stroke();   }}