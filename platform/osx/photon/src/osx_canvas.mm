/*=================================================================================================   Copyright (c) 2016 Joel de Guzman   Licensed under a Creative Commons Attribution-ShareAlike 4.0 International.   http://creativecommons.org/licenses/by-sa/4.0/=================================================================================================*/#include <photon/support/canvas.hpp>#include <photon/view.hpp>#include <Quartz/Quartz.h>#include "osx_view_state.hpp"struct canvas_impl;namespace photon{   canvas::canvas(canvas_impl* impl, view& view_)    : _impl(impl)    , _view(view_)   {      // Flip the text drawing vertically      auto ctx = CGContextRef(_impl);      CGAffineTransform trans = CGAffineTransformMakeScale(1, -1);      CGContextSetTextMatrix(ctx, trans);   }   void canvas::begin_path()   {      CGContextBeginPath(CGContextRef(_impl));   }   void canvas::close_path()   {      CGContextClosePath(CGContextRef(_impl));   }   void canvas::fill()   {      CGContextFillPath(CGContextRef(_impl));   }   void canvas::stroke()   {      CGContextStrokePath(CGContextRef(_impl));   }   void canvas::move_to(point p)   {      CGContextMoveToPoint(CGContextRef(_impl), p.x, p.y);   }   void canvas::line_to(point p)   {      CGContextAddLineToPoint(CGContextRef(_impl), p.x, p.y);   }   void canvas::arc_to(point p1, point p2, float radius)   {      CGContextAddArcToPoint(         CGContextRef(_impl),         p1.x, p1.y, p2.x, p2.y, radius      );   }   void canvas::arc(      point p, float radius,      float start_angle, float end_angle,      bool ccw   )   {      CGContextAddArc(         CGContextRef(_impl),         p.x, p.y, radius, start_angle, end_angle, !ccw      );   }   namespace detail   {      void round_rect(canvas& c, rect bounds, float radius)      {         auto x = bounds.left;         auto y = bounds.top;         auto r = bounds.right;         auto b = bounds.bottom;         c.begin_path();         c.move_to(point{ x, y + radius });         c.line_to(point{ x, b - radius });         c.arc_to(point{ x, b }, point{ x + radius, b }, radius);         c.line_to(point{ r - radius, b });         c.arc_to(point{ r, b }, point{ r, b - radius }, radius);         c.line_to(point{ r, y + radius });         c.arc_to(point{ r, y }, point{ r - radius, y }, radius);         c.line_to(point{ x + radius, y });         c.arc_to(point{ x, y }, point{ x, y + radius }, radius);      }   }   void canvas::rect(struct rect r)   {      CGContextAddRect(CGContextRef(_impl), CGRectMake(r.left, r.top, r.width(), r.height()));   }   void canvas::round_rect(struct rect r, float radius)   {      detail::round_rect(*this, r, radius);   }   void canvas::fill_color(color c)   {      CGContextSetRGBFillColor(CGContextRef(_impl), c.red, c.green, c.blue, c.alpha);   }   void canvas::stroke_color(color c)   {      CGContextSetRGBStrokeColor(CGContextRef(_impl), c.red, c.green, c.blue, c.alpha);   }   void canvas::line_width(float w)   {      CGContextSetLineWidth(CGContextRef(_impl), w);   }   void canvas::fill_rect(struct rect r)   {      CGContextFillRect(CGContextRef(_impl), CGRectMake(r.left, r.top, r.width(), r.height()));   }   void canvas::fill_round_rect(struct rect r, float radius)   {      round_rect(r, radius);      fill();   }   void canvas::stroke_rect(struct rect r)   {      CGContextStrokeRect(CGContextRef(_impl), CGRectMake(r.left, r.top, r.width(), r.height()));   }   void canvas::stroke_round_rect(struct rect r, float radius)   {      round_rect(r, radius);      stroke();   }   void canvas::font(char const* family, float size_, font_style style_)   {      auto  family_ = [NSString stringWithUTF8String:family];      int   style = 0;      if (style_ & bold)         style |= NSBoldFontMask;      if (style_ & italic)         style |= NSItalicFontMask;      auto font_manager = [NSFontManager sharedFontManager];      auto font =         [font_manager            fontWithFamily : family_                    traits : style                    weight : 0                      size : size_         ];      CFStringRef keys[] = { kCTFontAttributeName };      CFTypeRef   values[] = { (__bridge const void*)font };      if (_view._state->font_attributes)         CFRelease(_view._state->font_attributes);      _view._state->font_attributes = CFDictionaryCreate(        kCFAllocatorDefault, (const void**)&keys,        (const void**)&values, sizeof(keys) / sizeof(keys[0]),        &kCFTypeDictionaryKeyCallBacks,        &kCFTypeDictionaryValueCallBacks      );   }   void canvas::fill_text(point p, char const* f, char const* l)   {      auto ctx = CGContextRef(_impl);//      // $$$//      CGContextSetShadowWithColor(ctx, CGSizeMake(2.0f, -2.0f), 5.0f,//      [[NSColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:.6] CGColor]);      auto text = CFStringCreateWithCStringNoCopy(nullptr, f, kCFStringEncodingUTF8, nullptr);      auto attr_string =         CFAttributedStringCreate(kCFAllocatorDefault, text, _view._state->font_attributes);      CFRelease(text);      auto line = CTLineCreateWithAttributedString(attr_string);      CGContextSetTextPosition(ctx, p.x, p.y);      CTLineDraw(line, ctx);      CFRelease(line);   }}