/*=================================================================================================   Copyright (c) 2016 Joel de Guzman   Licensed under a Creative Commons Attribution-ShareAlike 4.0 International.   http://creativecommons.org/licenses/by-sa/4.0/=================================================================================================*/#if !defined(PHOTON_GUI_LIB_CANVAS_MAY_3_2016)#define PHOTON_GUI_LIB_CANVAS_MAY_3_2016#include <photon/support/color.hpp>#include <photon/support/rect.hpp>#include <photon/support/circle.hpp>#include <vector>#include <cmath>#include <cassert>#include <cairo.h>namespace photon{   class canvas   {   public:                        canvas(cairo_t* context_)                         : _context(context_)                        {}                        canvas(canvas&& rhs) = default;      canvas&           operator=(canvas&& rhs) = default;      /////////////////////////////////////////////////////////////////////////////////////////////      // Path building      void              begin_path();      void              close_path();      void              fill();      void              stroke();      void              clip();      void              move_to(point p);      void              line_to(point p);      void	            arc_to(point p1, point p2, float radius);      void	            arc(                           point p, float radius,                           float start_angle, float end_angle,                           bool ccw = false                        );      void              rect(struct rect r);      void              round_rect(struct rect r, float radius);      void              circle(struct circle c);      /////////////////////////////////////////////////////////////////////////////////////////////      // Styles      void              fill_style(color c);      void              stroke_style(color c);      void              line_width(float w);      void              shadow_style(point offs, float blur, color c = colors::black);      /////////////////////////////////////////////////////////////////////////////////////////////      // Gradients      struct linear_gradient      {         point start;         point end;      };      struct radial_gradient      {         point start;         float start_radius;         point end;         float end_radius;      };      struct color_stop      {         float offset;         color color;      };      void              fill_style(linear_gradient gr);      void              fill_style(radial_gradient gr);      void              color_space(std::vector<color_stop> const& space);      void              color_space(color_stop const space[], std::size_t nspaces);      /////////////////////////////////////////////////////////////////////////////////////////////      // Rectangles      void              fill_rect(struct rect r);      void              fill_round_rect(struct rect r, float radius);      void              stroke_rect(struct rect r);      void              stroke_round_rect(struct rect r, float radius);      /////////////////////////////////////////////////////////////////////////////////////////////      // Font      enum font_style      {         normal   = 0,         bold     = 1,         italic   = 2      };      void              font(char const* family, float size = 16, int = normal);      /////////////////////////////////////////////////////////////////////////////////////////////      // Text      enum text_alignment      {         // Horizontal align         left     = 0,        // Default, align text horizontally to left.         center   = 1,	      // Align text horizontally to center.         right    = 2,	      // Align text horizontally to right.         // Vertical align         baseline = 4,        // Default, align text vertically to baseline.         top      = 8,        // Align text vertically to top.         middle	= 12,       // Align text vertically to middle.         bottom	= 16        // Align text vertically to bottom.      };      struct text_metrics      {         float       ascent;         float       descent;         float       leading;         float       width;         struct rect bounds;      };      void              fill_text(point p, char const* f, char const* l = 0);      void              stroke_text(point p, char const* f, char const* l = 0);      text_metrics      measure_text(char const* f, char const* l = 0);      void              text_align(int align);      /////////////////////////////////////////////////////////////////////////////////////////////      // Image      class image      {      public:         class rep;                        image(char const* filename);                        ~image();         photon::size   size() const;      private:         friend class canvas;                        image(image const&) = delete;                        image& operator=(image const&) = delete;         rep*           _rep;      };      void              draw(image const& img, photon::rect src, photon::rect dest);      /////////////////////////////////////////////////////////////////////////////////////////////      // States      class state      {      public:                        state(canvas& cnv_) : cnv(&cnv_)    { cnv->save(); }                        state(state&& rhs) : cnv(rhs.cnv)   { rhs.cnv = 0; }                        ~state()                            { if (cnv) cnv->restore(); }         state&         operator=(state&& rhs)         {            cnv = rhs.cnv;            rhs.cnv = 0;            return *this;         }      private:         state(state const&) = delete;         state& operator=(state const&) = delete;         canvas* cnv;      };      state             new_state()   { return state{ *this }; }      void              save();      void              restore();   private:      cairo_t*          _context;   };   ////////////////////////////////////////////////////////////////////////////////////////////////   // Inlines   ////////////////////////////////////////////////////////////////////////////////////////////////   //inline void canvas::begin_path()   //{   //   cairo_new_path(_context);   //}   //   //inline void canvas::close_path()   //{   //   cairo_close_path(_context);   //}   //   //void canvas::fill_style(color c)   //{   //   cairo_set_source_rgba(_context, c.red, c.green, c.blue, c.alpha);   //}   //   //inline void canvas::circle(struct circle c)   //{   //   arc(point{ c.cx, c.cy }, c.radius, 0.0, 2 * M_PI);   //}   //   //inline void canvas::color_space(std::vector<color_stop> const& space)   //{   //   color_space(space.data(), space.size());   //}   //   //inline void canvas::fill_rect(struct rect r)   //{   //   rect(r);   //   fill();   //}   //   //inline void canvas::fill_round_rect(struct rect r, float radius)   //{   //   round_rect(r, radius);   //   fill();   //}   //   //inline void canvas::stroke_rect(struct rect r)   //{   //   rect(r);   //   stroke();   //}   //   //inline void canvas::stroke_round_rect(struct rect r, float radius)   //{   //   round_rect(r, radius);   //   stroke();   //}   inline void canvas::begin_path()   {      assert(false); // unimplemented   }   inline void canvas::close_path()   {      assert(false); // unimplemented   }   inline void canvas::fill()   {      assert(false); // unimplemented   }   inline void canvas::stroke()   {      assert(false); // unimplemented   }   inline void canvas::clip()   {      assert(false); // unimplemented   }   inline void canvas::move_to(point p)   {      assert(false); // unimplemented   }   inline void canvas::line_to(point p)   {      assert(false); // unimplemented   }   inline void canvas::arc_to(point p1, point p2, float radius)   {      assert(false); // unimplemented   }   inline void canvas::arc(      point p, float radius,      float start_angle, float end_angle,      bool ccw   )   {      assert(false); // unimplemented   }   inline void canvas::rect(struct rect r)   {      assert(false); // unimplemented   }   inline void canvas::round_rect(struct rect r, float radius)   {      assert(false); // unimplemented   }   inline void canvas::circle(struct circle c)   {      assert(false); // unimplemented   }   inline void canvas::fill_style(color c)   {      assert(false); // unimplemented   }   inline void canvas::stroke_style(color c)   {      assert(false); // unimplemented   }   inline void canvas::line_width(float w)   {      assert(false); // unimplemented   }   inline void canvas::shadow_style(point offs, float blur, color c)   {      assert(false); // unimplemented   }   inline void canvas::fill_style(linear_gradient gr)   {      assert(false); // unimplemented   }   inline void canvas::fill_style(radial_gradient gr)   {      assert(false); // unimplemented   }   inline void canvas::color_space(std::vector<color_stop> const& space)   {      assert(false); // unimplemented   }   inline void canvas::color_space(color_stop const space[], std::size_t nspaces)   {      assert(false); // unimplemented   }   inline void canvas::fill_rect(struct rect r)   {      assert(false); // unimplemented   }   inline void canvas::fill_round_rect(struct rect r, float radius)   {      assert(false); // unimplemented   }   inline void canvas::stroke_rect(struct rect r)   {      assert(false); // unimplemented   }   inline void canvas::stroke_round_rect(struct rect r, float radius)   {      assert(false); // unimplemented   }   inline void canvas::font(char const* family, float size, int)   {      assert(false); // unimplemented   }   inline void canvas::fill_text(point p, char const* f, char const* l)   {      assert(false); // unimplemented   }   inline void canvas::stroke_text(point p, char const* f, char const* l)   {      assert(false); // unimplemented   }   inline canvas::text_metrics canvas::measure_text(char const* f, char const* l)   {      assert(false); // unimplemented   }   inline void canvas::text_align(int align)   {      assert(false); // unimplemented   }   inline void canvas::draw(image const& img, photon::rect src, photon::rect dest)   {      assert(false); // unimplemented   }   inline void canvas::save()   {      assert(false); // unimplemented   }   inline void canvas::restore()   {      assert(false); // unimplemented   }      inline canvas::image::image(char const* filename)   {      assert(false); // unimplemented   }      inline canvas::image::~image()   {      assert(false); // unimplemented   }   inline photon::size canvas::image::size() const   {      assert(false); // unimplemented      return {};   }}#endif