/*=================================================================================================   Copyright (c) 2016 Joel de Guzman   Licensed under a Creative Commons Attribution-ShareAlike 4.0 International.   http://creativecommons.org/licenses/by-sa/4.0/=================================================================================================*/#if !defined(PHOTON_GUI_LIB_CANVAS_MAY_3_2016)#define PHOTON_GUI_LIB_CANVAS_MAY_3_2016#include <photon/point.hpp>#include <photon/rect.hpp>#include <photon/color.hpp>#include <nanovg.h>struct NVGcontext;namespace photon{   using paint = NVGpaint;	////////////////////////////////////////////////////////////////////////////////////////////////	// The Canvas   //   // Abstracts the NanoVG drawing context	////////////////////////////////////////////////////////////////////////////////////////////////   class canvas   {   public:      enum solidity      {         solid = NVG_SOLID,         hole = NVG_HOLE      };      canvas(NVGcontext* context = 0)       : _vg(context)      {}      NVGcontext*       context() const { return _vg; }      void              context(NVGcontext* vg_) { _vg = vg_; }      void              begin_path();      void              path_winding(solidity dir);      void              rect(struct rect r);      void              round_rect(struct rect r, float radius);      void              fill();      void              fill_color(color c);      void              fill_paint(paint const& p);      paint             box_gradient(                           struct rect r, float radius, float feather                         , color inner_color, color outer_color);      paint             linear_gradient(                           point start, point end                         , color inner_color, color outer_color);      void              stroke_color(color c);      void              stroke_width(float w);      void              stroke();      void              new_font(char const* name, char const* path);   private:      NVGcontext*       _vg;   };	////////////////////////////////////////////////////////////////////////////////////////////////   // Inlines	////////////////////////////////////////////////////////////////////////////////////////////////   inline NVGcolor nvgRGBA(color c)   {      NVGcolor color;      color.r = c.red;      color.g = c.green;      color.b = c.blue;      color.a = c.alpha;      return color;   }   inline void canvas::begin_path()   {      nvgBeginPath(_vg);   }   inline void canvas::path_winding(solidity dir)   {      nvgPathWinding(_vg, int(dir));   }   inline void canvas::rect(struct rect r)   {      nvgRect(_vg, r.left, r.top, r.width(), r.height());   }   inline void canvas::round_rect(struct rect r, float radius)   {      nvgRoundedRect(_vg, r.left, r.top, r.width(), r.height(), radius);   }   inline void canvas::fill()   {      nvgFill(_vg);   }   inline void canvas::fill_color(color c)   {      nvgFillColor(_vg, nvgRGBA(c));   }   inline void canvas::fill_paint(paint const& p)   {      nvgFillPaint(_vg, p);   }   inline paint canvas::box_gradient(      struct rect r, float radius, float feather    , color inner_color, color outer_color)   {      return nvgBoxGradient(_vg,            r.left, r.top, r.width(), r.height(), radius, feather          , nvgRGBA(inner_color), nvgRGBA(outer_color)         );   }   inline paint canvas::linear_gradient(      point start, point end    , color inner_color, color outer_color)   {      return nvgLinearGradient(            _vg, start.x, start.y, end.x, end.y,            nvgRGBA(inner_color), nvgRGBA(outer_color)         );   }   inline void canvas::stroke_color(color c)   {      nvgStrokeColor(_vg, nvgRGBA(c));   }   inline void canvas::stroke_width(float w)   {      nvgStrokeWidth(_vg, w);   }   inline void canvas::stroke()   {      nvgStroke(_vg);   }   inline void canvas::new_font(char const* name, char const* path)   {      if (nvgCreateFont(_vg, name, path) == -1)      {         // $$$ throw $$$      }   }}#endif