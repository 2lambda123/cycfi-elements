/*=================================================================================================   Copyright (c) 2016 Joel de Guzman   Licensed under a Creative Commons Attribution-ShareAlike 4.0 International.   http://creativecommons.org/licenses/by-sa/4.0/=================================================================================================*/#if !defined(PHOTON_GUI_LIB_CANVAS_MAY_3_2016)#define PHOTON_GUI_LIB_CANVAS_MAY_3_2016#include <photon/point.hpp>#include <photon/rect.hpp>#include <photon/color.hpp>#include <nanovg.h>struct NVGcontext;namespace photon{   using paint = NVGpaint;	////////////////////////////////////////////////////////////////////////////////////////////////	// The Canvas   //   // Abstracts the NanoVG drawing context	////////////////////////////////////////////////////////////////////////////////////////////////   class canvas   {   public:      enum solidity      {         solid = NVG_SOLID,         hole = NVG_HOLE      };      canvas(NVGcontext* context)       : _vg(context)      {}      NVGcontext*       context() const { return _vg; }      void              begin_path();      void              path_winding(solidity dir);      void              rect(struct rect const& r);      void              round_rect(struct rect const& r, float radius);      void              fill();      void              fill_color(color const& c);      void              fill_paint(paint const& p);      paint             box_gradient(                           struct rect const& r, float radius, float feather                         , color const& inner_color, color const& outer_color);   private:      NVGcontext*       _vg;   };	////////////////////////////////////////////////////////////////////////////////////////////////   // Inlines	////////////////////////////////////////////////////////////////////////////////////////////////   inline NVGcolor nvgRGBA(color const& c)   {      NVGcolor color;      color.r = c.red;      color.g = c.green;      color.b = c.blue;      color.a = c.alpha;      return color;   }   inline void canvas::begin_path()   {      nvgBeginPath(_vg);   }   inline void canvas::path_winding(solidity dir)   {      nvgPathWinding(_vg, int(dir));   }   inline void canvas::rect(struct rect const& r)   {      nvgRect(_vg, r.left, r.right, r.width(), r.height());   }   inline void canvas::round_rect(struct rect const& r, float radius)   {      nvgRoundedRect(_vg, r.left, r.right, r.width(), r.height(), radius);   }   inline void canvas::fill()   {      nvgFill(_vg);   }   inline void canvas::fill_color(color const& c)   {      nvgFillColor(_vg, nvgRGBA(c));   }   inline void canvas::fill_paint(paint const& p)   {      nvgFillPaint(_vg, p);   }   inline paint canvas::box_gradient(      struct rect const& r, float radius, float feather    , color const& inner_color, color const& outer_color)   {      return nvgBoxGradient(_vg,            r.left, r.right, r.width(), r.height(), radius, feather          , nvgRGBA(inner_color), nvgRGBA(outer_color)         );   }}#endif