/*=================================================================================================   Copyright (c) 2016 Joel de Guzman   Licensed under a Creative Commons Attribution-ShareAlike 4.0 International.   http://creativecommons.org/licenses/by-sa/4.0/=================================================================================================*/#if !defined(PHOTON_GUI_LIB_CANVAS_MAY_3_2016)#define PHOTON_GUI_LIB_CANVAS_MAY_3_2016#include <photon/point.hpp>#include <photon/rect.hpp>#include <photon/color.hpp>#include <photon/exception.hpp>#include <nanovg.h>struct NVGcontext;namespace photon{   using paint = NVGpaint;	////////////////////////////////////////////////////////////////////////////////////////////////	// The Canvas   //   // Abstracts the NanoVG drawing context	////////////////////////////////////////////////////////////////////////////////////////////////   class canvas   {   public:      enum solidity      {         solid = NVG_SOLID,         hole = NVG_HOLE      };      enum text_align      {         // Horizontal align         align_left     = NVG_ALIGN_LEFT,    // Default, align text horizontally to left.         align_center   = NVG_ALIGN_CENTER,	// Align text horizontally to center.         align_right    = NVG_ALIGN_RIGHT,	// Align text horizontally to right.         // Vertical align         align_top      = NVG_ALIGN_TOP,	   // Align text vertically to top.         align_middle   = NVG_ALIGN_MIDDLE,	// Align text vertically to middle.         align_bottom   = NVG_ALIGN_BOTTOM,	// Align text vertically to bottom.         align_baseline = NVG_ALIGN_BASELINE // Default, align text vertically to baseline.      };      canvas(NVGcontext* context = 0)       : _vg(context)      {}      NVGcontext*       context() const { return _vg; }      void              context(NVGcontext* vg_) { _vg = vg_; }      void              save();      void              restore();      void              clip(rect r);      void              begin_path();      void              path_winding(solidity dir);      void              rect(struct rect r);      void              round_rect(struct rect r, float radius);      void              circle(struct circle c);      void              fill();      void              fill_color(color c);      void              fill_paint(paint const& p);      paint             box_gradient(                           struct rect r, float radius, float feather                         , color inner_color, color outer_color);      paint             linear_gradient(                           point start, point end                         , color inner_color, color outer_color);      paint             radial_gradient(                           point center, float inr, float outr                         , color inner_color, color outer_color);      void              stroke_color(color c);      void              stroke_width(float w);      void              stroke();      void              new_font(char const* name, char const* path);      void              font_size(float size);      void              font_blur(float blur);      void              font_face(char const* font);      void              text_align(int align);      float             text(point p, char const* f, char const* l = 0);      float             text_width(char const* f, char const* l = 0);      void              text_box(point p, float width, char const* f, char const* l = 0);   private:      NVGcontext*       _vg;   };	////////////////////////////////////////////////////////////////////////////////////////////////   // Inlines	////////////////////////////////////////////////////////////////////////////////////////////////   inline NVGcolor nvgRGBA(color c)   {      NVGcolor color;      color.r = c.red;      color.g = c.green;      color.b = c.blue;      color.a = c.alpha;      return color;   }   inline void canvas::save()   {      nvgSave(_vg);   }   inline void canvas::restore()   {      nvgRestore(_vg);   }   inline void canvas::clip(struct rect r)   {      nvgScissor(_vg, r.left, r.top, r.width(), r.height());   }   inline void canvas::begin_path()   {      nvgBeginPath(_vg);   }   inline void canvas::path_winding(solidity dir)   {      nvgPathWinding(_vg, int(dir));   }   inline void canvas::rect(struct rect r)   {      nvgRect(_vg, r.left, r.top, r.width(), r.height());   }   inline void canvas::round_rect(struct rect r, float radius)   {      nvgRoundedRect(_vg, r.left, r.top, r.width(), r.height(), radius);   }   inline void canvas::circle(struct circle c)   {      nvgCircle(_vg, c.cx, c.cy, c.radius);   }   inline void canvas::fill()   {      nvgFill(_vg);   }   inline void canvas::fill_color(color c)   {      nvgFillColor(_vg, nvgRGBA(c));   }   inline void canvas::fill_paint(paint const& p)   {      nvgFillPaint(_vg, p);   }   inline paint canvas::box_gradient(      struct rect r, float radius, float feather    , color inner_color, color outer_color)   {      return nvgBoxGradient(_vg,            r.left, r.top, r.width(), r.height(), radius, feather          , nvgRGBA(inner_color), nvgRGBA(outer_color)         );   }   inline paint canvas::linear_gradient(      point start, point end    , color inner_color, color outer_color)   {      return nvgLinearGradient(            _vg, start.x, start.y, end.x, end.y,            nvgRGBA(inner_color), nvgRGBA(outer_color)         );   }   inline paint canvas::radial_gradient(      point center, float inr, float outr    , color inner_color, color outer_color)   {      return nvgRadialGradient(            _vg, center.x, center.y, inr, outr,            nvgRGBA(inner_color), nvgRGBA(outer_color)         );   }   inline void canvas::stroke_color(color c)   {      nvgStrokeColor(_vg, nvgRGBA(c));   }   inline void canvas::stroke_width(float w)   {      nvgStrokeWidth(_vg, w);   }   inline void canvas::stroke()   {      nvgStroke(_vg);   }   inline void canvas::new_font(char const* name, char const* path)   {      if (nvgCreateFont(_vg, name, path) == -1)         throw nanovg_exception("Failed to create font.");   }   inline void canvas::font_size(float size)   {      nvgFontSize(_vg, size);   }   inline void canvas::font_blur(float blur)   {      nvgFontBlur(_vg, blur);   }   inline void canvas::font_face(char const* font)   {      nvgFontFace(_vg, font);   }   inline void canvas::text_align(int align)   {      nvgTextAlign(_vg, align);   }   inline float canvas::text(point p, char const* f, char const* l)   {      return nvgText(_vg, p.x, p.y, f, l);   }   inline float canvas::text_width(char const* f, char const* l)   {      return nvgTextBounds(_vg, 0, 0, f, l, 0);   }   inline void canvas::text_box(point p, float width, char const* f, char const* l)   {      nvgTextBox(_vg, p.x, p.y, width, f, l);   }}#endif